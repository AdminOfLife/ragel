namespace host
	lex 
		rl NL / '\n' /

		rl s_literal
			/ "'" ([^'\\] | NL | '\\' (any | NL))* "'" /

		rl d_literal
			/ '"' ([^"\\] | NL | '\\' (any | NL))* '"' /

		rl c_comment 
			/ '/*' ( any | NL )* :>> '*/' /

		rl cpp_comment
			/ '//' [^\n]* NL /

		token ident
			/( alpha | '_' ) ( alpha | digit | '_' )*/

		token uint
			/ digit+ /

		token hex_number
			/ '0x' [0-9a-fA-F]+ /

		token comment
			/ c_comment | cpp_comment /

		token string
			/ s_literal | d_literal /

		token whitespace
			/ ( [ \t] | NL )+ /

		literal '}$'

		token c_any / any /
	end

	def tok
		[ident]
	|	[uint]
	|	[hex_number]
	|	[comment]
	|	[string]
	|	[whitespace]
	|	[c_any]

	def out
		[tok*]
end

namespace gen
	lex 
		rl NL / '\n' /

		rl s_literal
			/ "'" ([^'\\] | NL | '\\' (any | NL))* "'" /

		rl d_literal
			/ '"' ([^"\\] | NL | '\\' (any | NL))* '"' /

		rl c_comment 
			/ '/*' ( any | NL )* :>> '*/' /

		rl cpp_comment
			/ '//' [^\n]* NL /

		literal 'array', 'value', 'TRUE', 'FALSE',
				'while', 'switch', 'case',
				'if', 'else'

		token ident
			/( alpha | '_' ) ( alpha | digit | '_' )*/

		token uint
			/ digit+ [u]? /

		token hex_number
			/ '0x' [0-9a-fA-F]+ /

		ignore
			/ c_comment | cpp_comment /

		token string
			/ s_literal | d_literal /

		ignore / ( [ \t] | NL )+ /

		token pragma /'#' any* :> '\n' /

		literal '$', '{', '}', '=', '[', ']',
				'-', ',', ';', '(', ')', ':',
				'?', '*', '+', '>', '<', '&',
				'~', '!', '!=', '==', '<<', '>>',
				'+=', '&&', '||', '<=', '>=', '->',
				'++', '--'
	end

	def embedded_host
		['$' string uint '{' host::tok* host::'}$']

	def expr_factor
		[embedded_host]
	|	[ident]
	|	[ident '[' expr ']']
	|	[uint]
	|	['-' uint]
	|	['TRUE']
	|	['FALSE']
	|	[hex_number]
	|	[string]
	|	['(' expr ')']

	def expr_ptr
		[expr_ptr '->' expr_factor]
	|	['*' expr_ptr]
	|	['++' expr_ptr]
	|	['--' expr_ptr]
	|	[expr_ptr '++']
	|	[expr_ptr '--']
	|	['(' ident+ ')' expr_ptr]
	|	[expr_factor]

	def expr_factor_op
		['!' expr_factor_op]
	|	['~' expr_factor_op]
	|	[expr_ptr]

	def expr_bitwise
		[expr_bitwise '&' expr_factor_op]
	|	[expr_factor_op]

	def expr_mult
		[expr_mult '*' expr_bitwise]
	|	[expr_bitwise]

	def expr_add
		[expr_add '+' expr_mult]
	|	[expr_add '-' expr_mult]
	|	[expr_mult]

	def expr_shift
		[expr_shift '<<' expr_add]
	|	[expr_shift '>>' expr_add]
	|	[expr_add]

	def expr_test
		[expr_test '<' expr_shift]
	|	[expr_test '>' expr_shift]
	|	[expr_test '<=' expr_shift]
	|	[expr_test '>=' expr_shift]
	|	[expr_test '==' expr_shift]
	|	[expr_test '!=' expr_shift]
	|	[expr_test '&&' expr_shift]
	|	[expr_test '||' expr_shift]
	|	[expr_shift]

	def expr_cond
		[expr_test '?' expr ':' expr_cond]
	|	[expr_test]

	def expr_assign
		[expr_assign '=' expr_cond]
	|	[expr_assign '+=' expr_cond]
	|	[expr_cond]

	def expr
		[expr_assign]
	
	def number
		[uint]
	|	['-' uint]

	def comma_num
		[',' number]

	def num_list
		[number comma_num*]
	|	[]

	def type
		[ident]
	|	[ident ident]

	def array_pass
		[type ident '[' ']' '=' '{' num_list '}' ';']

	def array
		['array' array_pass]
	
	def value_pass
		[type ident '=' number ';']

	def value
		['value' value_pass]
	
	def while_stmt
		['while' '(' expr ')' stmt]
	
	def else_if_clause
		['else' 'if' '(' expr ')' stmt]

	def else_clause
		['else' stmt]

	def if_stmt [
		'if' '(' expr ')' stmt
		else_if_clause* else_clause?
	]

	def switch_stmt
		['switch' '(' expr ')' stmt]

	def case_label
		['case' expr ':']

	def goto_label
		[ident ':']

	def opt_init
		['=' expr]
	|	[]

	def opt_ptr
		['*']
	|	[]

	def declaration
		[ident+ opt_ptr ident opt_init ';']

	def stmt
		[embedded_host]
	|	[array]
	|	[value]
	|	[declaration]
	|	[while_stmt]
	|	[if_stmt]
	|	[switch_stmt]
	|	[case_label]
	|	[goto_label]
	|	[expr ';']
	|	[pragma]
	|	['{' stmt* '}']

	def start
		[stmt*]

	int trans_expr_factor( Output: stream ExprFactor: expr_factor )
	{
		if match ExprFactor
			['$' string uint '{' TL: host::tok* host::'}$']
		{
			prints( Output TL )
		}
		elsif match ExprFactor
			[O:'(' TL: expr C: ')']
		{
			prints( Output O )
			trans_expr( Output TL )
			prints( Output C )
		}
		elsif match ExprFactor
			[ident O: '[' TL: expr C: ']']
		{
			prints( Output ExprFactor.ident )
			prints( Output '/* subscript */' )
			prints( Output O )
			trans_expr( Output TL )
			prints( Output C )
		}
		elsif match ExprFactor
				[T: 'TRUE']
		{
			T.data = '1'
			prints( Output T )
		}
		elsif match ExprFactor
				[F: 'FALSE']
		{
			F.data = '0'
			prints( Output F )
		}
		else {
			# Catches cases not specified
			prints( Output ExprFactor )
		}
	}

	int trans_expr_ptr( Output: stream ExprPtr: expr_ptr )
	{
		if match ExprPtr [expr_ptr Arrow: '->' expr_factor]
		{
			trans_expr_ptr( Output ExprPtr._expr_ptr )
			prints( Output Arrow )
			trans_expr_factor( Output ExprPtr.expr_factor )
		}
		elsif match ExprPtr [Star: '*' expr_ptr]
		{
			prints( Output Star )
			trans_expr_ptr( Output ExprPtr._expr_ptr )
		}
		elsif match ExprPtr [PP: '++' expr_ptr]
		{
			prints( Output PP )
			trans_expr_ptr( Output ExprPtr._expr_ptr )
		}
		elsif match ExprPtr [MM: '--' expr_ptr]
		{
			prints( Output MM )
			trans_expr_ptr( Output ExprPtr._expr_ptr )
		}
		elsif match ExprPtr [expr_ptr PP: '++']
		{
			trans_expr_ptr( Output ExprPtr._expr_ptr )
			prints( Output PP )
		}
		elsif match ExprPtr [expr_ptr MM: '--']
		{
			trans_expr_ptr( Output ExprPtr._expr_ptr )
			prints( Output MM )
		}
		elsif match ExprPtr [Open: '(' Type: ident+ Close: ')' expr_ptr]
		{
			prints( Output Open )
			prints( Output Type )
			prints( Output Close )
			trans_expr_ptr( Output ExprPtr._expr_ptr )
		}
		elsif match ExprPtr [expr_factor]
		{
			trans_expr_factor( Output ExprPtr.expr_factor )
		}
		else {
			prints( Output ExprPtr )
		}
	}
	
	int trans_expr_factor_op( Output: stream ExprFactorOp: expr_factor_op )
	{
		if match ExprFactorOp [B: '!' expr_factor_op]
		{
			prints( Output '/* bang */' )
			prints( Output B )
			trans_expr_factor_op( Output ExprFactorOp._expr_factor_op )
		}
		elsif match ExprFactorOp [T: '~' expr_factor_op]
		{
			prints( Output '/* tilde */' )
			prints( Output T )
			trans_expr_factor_op( Output ExprFactorOp._expr_factor_op )
		}
		elsif match ExprFactorOp [expr_ptr]
		{
			trans_expr_ptr( Output ExprFactorOp.expr_ptr )
		}
	}

	int trans_expr_bitwise( Output: stream ExprBitwise: expr_bitwise )
	{
		if match ExprBitwise [expr_bitwise A: '&' expr_factor_op]
		{
			prints( Output '/* bitwise and */' )
			trans_expr_bitwise( Output ExprBitwise._expr_bitwise )
			prints( Output A )
			trans_expr_factor_op( Output ExprBitwise.expr_factor_op )
		}
		elsif match ExprBitwise [expr_factor_op]
		{
			trans_expr_factor_op( Output ExprBitwise.expr_factor_op )
		}
	}

	int trans_expr_mult( Output: stream ExprMult: expr_mult )
	{
		if match ExprMult [expr_mult T: '*' expr_bitwise]
		{
			prints( Output '/* mult */' )
			trans_expr_mult( Output ExprMult._expr_mult )
			prints( Output T )
			trans_expr_bitwise( Output ExprMult.expr_bitwise )
		}
		elsif match ExprMult [expr_bitwise]
		{
			trans_expr_bitwise( Output ExprMult.expr_bitwise )
		}
	}

	int trans_expr_add( Output: stream ExprAdd: expr_add )
	{
		if match ExprAdd [expr_add Plus: '+' expr_mult]
		{
			prints( Output '/* add */' )
			trans_expr_add( Output ExprAdd._expr_add )
			prints( Output Plus )
			trans_expr_mult( Output ExprAdd.expr_mult )
		}
		elsif match ExprAdd [expr_add Minus: '-' expr_mult]
		{
			prints( Output '/* sub */' )
			trans_expr_add( Output ExprAdd._expr_add )
			prints( Output Minus )
			trans_expr_mult( Output ExprAdd.expr_mult )
		}
		elsif match ExprAdd [expr_mult]
		{
			trans_expr_mult( Output ExprAdd.expr_mult )
		}
	}

	int trans_expr_shift( Output: stream ExprShift: expr_shift )
	{
		if match ExprShift [expr_shift LL: '<<' expr_add]
		{
			prints( Output '/* lshift */' )
			trans_expr_shift( Output ExprShift._expr_shift )
			prints( Output LL )
			trans_expr_add( Output ExprShift.expr_add )
		}
		elsif match ExprShift [expr_shift RR: '>>' expr_add]
		{
			prints( Output '/* rshift */' )
			trans_expr_shift( Output ExprShift._expr_shift )
			prints( Output RR )
			trans_expr_add( Output ExprShift.expr_add )
		}
		elsif match ExprShift [expr_add]
		{
			trans_expr_add( Output ExprShift.expr_add )
		}
	}

	int trans_expr_test( Output: stream ExprTest: expr_test )
	{
		if match ExprTest [expr_test LT: '<' expr_shift]
		{
			prints( Output '/* lt */' )
			trans_expr_test( Output ExprTest._expr_test )
			prints( Output LT )
			trans_expr_shift( Output ExprTest.expr_shift )
		}
		elsif match ExprTest [expr_test GT: '>' expr_shift]
		{
			prints( Output '/* gt */' )
			trans_expr_test( Output ExprTest._expr_test )
			prints( Output GT )
			trans_expr_shift( Output ExprTest.expr_shift )
		}
		elsif match ExprTest [expr_test LTE: '<=' expr_shift]
		{
			prints( Output '/* lte */' )
			trans_expr_test( Output ExprTest._expr_test )
			prints( Output LTE )
			trans_expr_shift( Output ExprTest.expr_shift )
		}
		elsif match ExprTest [expr_test GTE: '>=' expr_shift]
		{
			prints( Output '/* gte */' )
			trans_expr_test( Output ExprTest._expr_test )
			prints( Output GTE )
			trans_expr_shift( Output ExprTest.expr_shift )
		}
		elsif match ExprTest [expr_test EQ: '==' expr_shift]
		{
			prints( Output '/* equals */' )
			trans_expr_test( Output ExprTest._expr_test )
			prints( Output EQ )
			trans_expr_shift( Output ExprTest.expr_shift )
		}
		elsif match ExprTest [expr_test NE: '!=' expr_shift]
		{
			prints( Output '/* not equals */' )
			trans_expr_test( Output ExprTest._expr_test )
			prints( Output NE )
			trans_expr_shift( Output ExprTest.expr_shift )
		}
		elsif match ExprTest [expr_test AND: '&&' expr_shift]
		{
			prints( Output '/* logical and */' )
			trans_expr_test( Output ExprTest._expr_test )
			prints( Output AND )
			trans_expr_shift( Output ExprTest.expr_shift )
		}
		elsif match ExprTest [expr_test OR: '||' expr_shift]
		{
			prints( Output '/* logical or */' )
			trans_expr_test( Output ExprTest._expr_test )
			prints( Output OR )
			trans_expr_shift( Output ExprTest.expr_shift )
		}
		elsif match ExprTest [expr_shift]
		{
			trans_expr_shift( Output ExprTest.expr_shift )
		}
	}

	int trans_expr_cond( Output: stream ExprCond: expr_cond )
	{
		if match ExprCond [expr_test Q: '?' expr C: ':' expr_cond]
		{
			prints( Output '/* cond test */' )
			trans_expr_test( Output ExprCond.expr_test )
			prints( Output Q )
			prints( Output '/* cond true */' )
			trans_expr( Output ExprCond.expr )
			prints( Output C )
			prints( Output '/* cond false */' )
			trans_expr_cond( Output ExprCond._expr_cond )
		}
		elsif match ExprCond [expr_test]
		{
			trans_expr_test( Output ExprCond.expr_test )
		}
	}

	int trans_expr_assign( Output: stream ExprAssign: expr_assign )
	{
		if match ExprAssign [expr_assign E: '=' expr_cond]
		{
			prints( Output '/* assign */' )
			trans_expr_assign( Output ExprAssign._expr_assign )
			prints( Output E )
			trans_expr_cond( Output ExprAssign.expr_cond )
		}
		elsif match ExprAssign [expr_assign PE: '+=' expr_cond]
		{
			prints( Output '/* +assign */' )
			trans_expr_assign( Output ExprAssign._expr_assign )
			prints( Output PE )
			trans_expr_cond( Output ExprAssign.expr_cond )
		}
		elsif match ExprAssign [expr_cond]
		{
			trans_expr_cond( Output ExprAssign.expr_cond )
		}
	}

	int trans_expr( Output: stream Expr: expr )
	{
		trans_expr_assign( Output Expr.expr_assign )
	}

	int trans_stmt( Output: stream Stmt: stmt )
	{
		if match Stmt
			['$' string uint '{' TL: host::tok* host::'}$']
		{
			prints( Output TL )
		}
		elsif match Stmt [Array: array] {
			prints( Output 'static const ' Array.array_pass )
		}
		elsif match Stmt [Value: value] {
			prints( Output 'static const ' Value.value_pass )
		}
		elsif match Stmt [
				'if' O: '(' IfExpr: expr C: ')' IfStmt: stmt
				ElseIfClauseList: else_if_clause* ElseClauseOpt: else_clause?
		] {
			prints( Output '/* if */ if ' O )
			trans_expr( Output IfExpr )
			prints( Output C )

			trans_stmt( Output IfStmt )

			for ElseIfClause: else_if_clause in repeat( ElseIfClauseList ) {
				match ElseIfClause
					['else' 'if' O2: '(' ElseIfExpr: expr C2: ')' ElseIfStmt: stmt]

				prints( Output '/* else if */ else if ' O2 )
				trans_expr( Output ElseIfExpr )
				prints( Output C2 )

				trans_stmt( Output ElseIfStmt )
			}

			if ( match ElseClauseOpt ['else' ElseStmt: stmt] ) {
				prints( Output '/* else */ else ' )
				trans_stmt( Output ElseStmt )
			}
		}
		elsif match Stmt ['while' O: '(' WhileExpr: expr C: ')' WhileStmt: stmt] {
			prints( Output 'while ' O )
			trans_expr( Output WhileExpr )
			prints( Output C )
			trans_stmt( Output WhileStmt )
		}
		elsif match Stmt ['switch' O: '(' SwitchExpr: expr C: ')' SwitchStmt: stmt] {
			prints( Output '/* switch */ switch ' O )
			trans_expr( Output SwitchExpr )
			prints( Output C )
			trans_stmt( Output SwitchStmt )
		}
		elsif match Stmt [ExprExpr: expr Semi: ';'] {
			prints( Output '/* expr */ ' )
			trans_expr( Output ExprExpr )
			prints( Output Semi )
		}
		elsif match Stmt [L: '{' TL: stmt* R: '}'] {
			prints( Output L )
			trans_stmt_list( Output TL )
			prints( Output R )
		}
		elsif match Stmt [TypeList: ident+ OptPtr: opt_ptr Ident: ident OptInit: opt_init Semi: ';']
		{
			prints( Output TypeList OptPtr Ident  )
			if match OptInit ['=' expr] {
				prints( Output '=' )
				trans_expr( Output OptInit.expr )
			}
			prints( Output Semi )
		}
		else {
			# catches unspecified cases
			prints( Output Stmt )
		}
	}

	int trans_stmt_list( Output: stream StmtList: stmt* )
	{
		for Stmt: stmt in repeat( StmtList )
			trans_stmt( Output Stmt )
	}
end

InputFile: str = argv.pop()
OutputFile: str = argv.pop()

Input: stream = open( InputFile "r" )

parse Start: gen::start[ Input ]

if ( !Start ) {
	print( error '\n' )
	exit(1)
}

Output: stream = open( OutputFile "w" )
trans_stmt_list( Output Start._repeat_stmt )
