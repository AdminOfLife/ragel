namespace host
	lex 
		rl NL / '\n' /

		rl s_literal
			/ "'" ([^'\\] | NL | '\\' (any | NL))* "'" /

		rl d_literal
			/ '"' ([^"\\] | NL | '\\' (any | NL))* '"' /

		rl c_comment 
			/ '/*' ( any | NL )* :>> '*/' /

		rl cpp_comment
			/ '//' [^\n]* NL /

		token ident
			/( alpha | '_' ) ( alpha | digit | '_' )*/

		token uint
			/ digit+ /

		token hex_number
			/ '0x' [0-9a-fA-F]+ /

		token comment
			/ c_comment | cpp_comment /

		token string
			/ s_literal | d_literal /

		token whitespace
			/ ( [ \t] | NL )+ /

		literal '}$'

		token c_any / any /
	end

	def tok
		[ident]
	|	[uint]
	|	[hex_number]
	|	[comment]
	|	[string]
	|	[whitespace]
	|	[c_any]

	def out
		[tok*]
	
	tok* concat( H: tok* T: tok* )
	{
		for L: tok* in H {
			if match L [] {
				L = T
				break
			}
		}
		return H
	}
end

namespace gen
	lex 
		rl NL / '\n' /

		rl s_literal
			/ "'" ([^'\\] | NL | '\\' (any | NL))* "'" /

		rl d_literal
			/ '"' ([^"\\] | NL | '\\' (any | NL))* '"' /

		rl c_comment 
			/ '/*' ( any | NL )* :>> '*/' /

		rl cpp_comment
			/ '//' [^\n]* NL /

		literal 'array', 'value', 'while', 'TRUE'

		token ident
			/( alpha | '_' ) ( alpha | digit | '_' )*/

		token uint
			/ digit+ [u]? /

		token hex_number
			/ '0x' [0-9a-fA-F]+ /

		token comment
			/ c_comment | cpp_comment /

		token string
			/ s_literal | d_literal /

		ignore / ( [ \t] | NL )+ /

		literal '$', '{', '}', '=', '[', ']',
				'-', ',', ';', '(', ')'

		token c_any / any /
	end

	def embedded_host
		['$' string uint '{' host::tok* host::'}$']

	def number
		[uint]
	|	['-' uint]

	def comma_num
		[',' number]

	def num_list
		[number comma_num*]
	|	[]

	def type
		[ident]
	|	[ident ident]

	def array_pass
		[type ident '[' ']' '=' '{' num_list '}' ';']

	def array
		['array' array_pass]
	
	def value_pass
		[type ident '=' number ';']

	def value
		['value' value_pass]
	
	def while_true
		['while' '(' tok* ')' '{' TokList: tok* '}']

	def tok
		[embedded_host]
	|	[array]
	|	[value]
	|	[while_true]
	|	[ident]
	|	[uint]
	|	[hex_number]
	|	['TRUE']
	|	[comment]
	|	[string]
	|	['='] |	['['] | [']']
	|	['-'] | [','] | [';']
	|	['{' tok* '}']
	|	['(' tok* ')']
	|	[c_any]

	def start
		[tok*]

	int trans( Output: stream TokList: tok* )
	{
		cons OutList: host::tok* []
		for Tok: tok in repeat(TokList) {
			if match Tok
				['$' string uint '{' TL: host::tok* host::'}$']
			{
				prints( Output TL )
			}
			elsif match Tok [Array: array] {
				prints( Output 'static const ' Array.array_pass )
			}
			elsif match Tok [Value: value] {
				prints( Output 'static const ' Value.value_pass )
			}
			elsif match Tok ['while' '(' 'TRUE' ')' '{' TokList: tok* '}'] {
				prints( Output 'while ( 1 ) {\n' )
				trans( Output TokList )
				prints( Output '}\n' )
			}
			elsif match Tok [L: '{' TL: tok* R: '}'] {
				prints( Output L )
				trans( Output TL )
				prints( Output R )
			}
			elsif match Tok [L: '(' TL: tok* R: ')'] {
				prints( Output L )
				trans( Output TL )
				prints( Output R )
			}
			else
			{
				prints( Output Tok )
			}
		}
	}
end

InputFile: str = argv.pop()
OutputFile: str = argv.pop()

Input: stream = open( InputFile "r" )

parse Start: gen::start[ Input ]

if ( !Start ) {
	print( error '\n' )
	exit(1)
}

Output: stream = open( OutputFile "w" )
trans( Output Start._repeat_tok )
