namespace host
	lex 
		rl NL / '\n' /

		rl s_literal
			/ "'" ([^'\\] | NL | '\\' (any | NL))* "'" /

		rl d_literal
			/ '"' ([^"\\] | NL | '\\' (any | NL))* '"' /

		rl c_comment 
			/ '/*' ( any | NL )* :>> '*/' /

		rl cpp_comment
			/ '//' [^\n]* NL /

		token ident
			/( alpha | '_' ) ( alpha | digit | '_' )*/

		token uint
			/ digit+ /

		token hex_number
			/ '0x' [0-9a-fA-F]+ /

		token comment
			/ c_comment | cpp_comment /

		token string
			/ s_literal | d_literal /

		token whitespace
			/ ( [ \t] | NL )+ /

		literal '}$'

		token c_any / any /
	end

	def tok
		[ident]
	|	[uint]
	|	[hex_number]
	|	[comment]
	|	[string]
	|	[whitespace]
	|	[c_any]

	def out
		[tok*]
	
	tok* concat( H: tok* T: tok* )
	{
		for L: tok* in H {
			if match L [] {
				L = T
				break
			}
		}
		return H
	}
end

namespace gen
	lex 
		rl NL / '\n' /

		rl s_literal
			/ "'" ([^'\\] | NL | '\\' (any | NL))* "'" /

		rl d_literal
			/ '"' ([^"\\] | NL | '\\' (any | NL))* '"' /

		rl c_comment 
			/ '/*' ( any | NL )* :>> '*/' /

		rl cpp_comment
			/ '//' [^\n]* NL /

		literal 'array', 'value', 'TRUE', 'FALSE',
				'while', 'switch', 'case',
				'if', 'else'

		token ident
			/( alpha | '_' ) ( alpha | digit | '_' )*/

		token uint
			/ digit+ [u]? /

		token hex_number
			/ '0x' [0-9a-fA-F]+ /

		ignore
			/ c_comment | cpp_comment /

		token string
			/ s_literal | d_literal /

		ignore / ( [ \t] | NL )+ /

		literal '$', '{', '}', '=', '[', ']',
				'-', ',', ';', '(', ')', ':',
				'?', '*', '+', '>', '<', '&',
				'~', '!'
	end

	def embedded_host
		['$' string uint '{' host::tok* host::'}$']

	def number
		[uint]
	|	['-' uint]

	def comma_num
		[',' number]

	def num_list
		[number comma_num*]
	|	[]

	def type
		[ident]
	|	[ident ident]

	def array_pass
		[type ident '[' ']' '=' '{' num_list '}' ';']

	def array
		['array' array_pass]
	
	def value_pass
		[type ident '=' number ';']

	def value
		['value' value_pass]
	
	def while_stmt
		['while' '(' expr_tok* ')' stmt]
	
	def else_if_clause
		['else' 'if' '(' expr_tok* ')' stmt]

	def else_clause
		['else' stmt]

	def if_stmt [
		'if' '(' expr_tok* ')' stmt
		else_if_clause* else_clause?
	]

	def switch_stmt
		['switch' '(' expr_tok* ')' stmt]

	def case_label
		['case' expr_tok* ':']

	def goto_label
		[ident ':']

	def expr_tok
		[embedded_host]
	|	[ident]
	|	[uint]
	|	['TRUE']
	|	['FALSE']
	|	[hex_number]
	|	[string]
	|	['['] | [']']
	| 	['='] | ['-'] | [',']
	|	['?'] | [':'] | ['*']
	|	['+'] | ['<'] | ['>']
	|	['&'] | ['~'] | ['!']
	|	['(' expr_tok* ')']

	def stmt
		[embedded_host]
	|	[array]
	|	[value]
	|	[while_stmt]
	|	[if_stmt]
	|	[switch_stmt]
	|	[case_label]
	|	[goto_label]
	|	[expr_tok* ';']
	|	['{' stmt* '}']

	def start
		[stmt*]

	int trans_expr( Output: stream Expr: expr_tok* )
	{
		for ExprTok: expr_tok in repeat(Expr) {
			if match ExprTok
				['$' string uint '{' TL: host::tok* host::'}$']
			{
				prints( Output TL )
			}
			elsif match ExprTok
				['(' TL: expr_tok* ')']
			{
				prints( Output '(' )
				trans_expr( Output TL )
				prints( Output ')' )
			}
			elsif match ExprTok
					['TRUE']
			{
				prints( Output '1' )
			}
			elsif match ExprTok
					['FALSE']
			{
				prints( Output '0' )
			}
			else {
				prints( Output ExprTok )
			}
		}
	}

	int trans_stmt( Output: stream Stmt: stmt )
	{
		if match Stmt
			['$' string uint '{' TL: host::tok* host::'}$']
		{
			prints( Output TL )
		}
		elsif match Stmt [Array: array] {
			prints( Output 'static const ' Array.array_pass )
		}
		elsif match Stmt [Value: value] {
			prints( Output 'static const ' Value.value_pass )
		}
		elsif match Stmt [
				'if' '(' IfExpr: expr_tok* ')' IfStmt: stmt
				ElseIfClauseList: else_if_clause* ElseClauseOpt: else_clause?
		] {
			prints( Output '/* if */ if ( ' )
			trans_expr( Output IfExpr )
			prints( Output ')\n' )

			trans_stmt( Output IfStmt )

			for ElseIfClause: else_if_clause in repeat( ElseIfClauseList ) {
				match ElseIfClause
					['else' 'if' '(' ElseIfExpr: expr_tok* ')' ElseIfStmt: stmt]

				prints( Output '/* else if */ else if ( ' )
				trans_expr( Output ElseIfExpr )
				prints( Output ')\n' )

				trans_stmt( Output ElseIfStmt )
			}

			if ( match ElseClauseOpt ['else' ElseStmt: stmt] ) {
				prints( Output '/* else */ else' )
				trans_stmt( Output ElseStmt )
			}
		}
		elsif match Stmt ['while' '(' WhileExpr: expr_tok* ')' WhileStmt: stmt] {
			prints( Output 'while ( ' )
			trans_expr( Output WhileExpr )
			prints( Output ')\n' )
			trans_stmt( Output WhileStmt )
		}
		elsif match Stmt ['switch' '(' SwitchExpr: expr_tok* ')' SwitchStmt: stmt] {
			prints( Output '/* switch */ switch ( ' )
			trans_expr( Output SwitchExpr )
			prints( Output ')\n' )
			trans_stmt( Output SwitchStmt )
		}
		elsif match Stmt [ExprExpr: expr_tok* ';'] {
			prints( Output '/* expr */ ' )
			trans_expr( Output ExprExpr )
			prints( Output ';\n' )
		}
		elsif match Stmt [L: '{' TL: stmt* R: '}'] {
			prints( Output L )
			trans_stmt_list( Output TL )
			prints( Output R )
		}
		else {
			prints( Output Stmt )
		}
	}

	int trans_stmt_list( Output: stream StmtList: stmt* )
	{
		for Stmt: stmt in repeat( StmtList )
			trans_stmt( Output Stmt )
	}
end

InputFile: str = argv.pop()
OutputFile: str = argv.pop()

Input: stream = open( InputFile "r" )

parse Start: gen::start[ Input ]

if ( !Start ) {
	print( error '\n' )
	exit(1)
}

Output: stream = open( OutputFile "w" )
trans_stmt_list( Output Start._repeat_stmt )
