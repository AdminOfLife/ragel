rl ident
	/( alpha | '_' ) ( alpha | digit | '_' )*/

rl number
	/ digit+ /

rl hex_number
	/ '0x' [0-9a-fA-F]+ /

rl NL / '\n' /

rl c_comment 
	/ '/*' ( any | NL )* :>> '*/' /

rl cpp_comment
	/ '//' [^\n]* NL /

rl s_literal
	/ "'" ([^'\\] | NL | '\\' (any | NL))* "'" /

rl d_literal
	/ '"' ([^"\\] | NL | '\\' (any | NL))* '"' /

namespace srlex
	lex
		ignore /[\t\n ]+/
		literal '::', ';', ')'
		token word /[a-zA-Z_][a-zA-Z0-9_]*/
	end
end

namespace c_inline
	lex 
		literal 'fpc', 'fc', 'fcurs', 'ftargs',
			'fentry', 'fhold', 'fexec', 'fgoto', 'fnext',
			'fcall', 'fret', 'fbreak'

		token ident /ident/
		token number /digit+/
		token hex_number /'0x' [0-9a-fA-F]+/

		token comment
			/ c_comment | cpp_comment /

		token string
			/ s_literal | d_literal /

		token whitespace
			/ ( [ \t] | NL )+ /

		literal '{', '}', '::', '*', ',', '(', ')', ';'

		token c_any / any /
	end

	def inline_expr
		[ExprItemList: expr_item*]

	def expr_item
		[ExprAny: expr_any] :ExprAny
	|	[ExprSymbol: expr_symbol] :ExprSymbol
	|	[ExprInterpret: expr_interpret] :ExprInterpret

	def expr_any
		[whitespace]
	|	[comment]
	|	[string]
	|	[number]
	|	[hex_number]
	|	[ident]
	|	[c_any]

	def expr_symbol
		[','] | ['('] | [')'] | ['*'] | ['::']

	def expr_interpret
		['fpc'] :Fpc
	|	['fc'] :Fc
	|	['fcurs'] :Fcurs
	|	['ftargs']  :Ftargs
	|	['fentry' '(' StateRef: state_ref srlex::')'] :Fentry

	def state_ref
		[OptNameSep: opt_name_sep StateRefNames: state_ref_names]


	def opt_name_sep
		[srlex::'::'] :ColonColon
	|	[] :Empty

	# List of names separated by ::
	def state_ref_names
		[StateRefNames: state_ref_names srlex::'::' Word: srlex::word] :Rec
	|	[Word: srlex::word] :Base

	def inline_block
		[BlockItemList: block_item*]
	
	def block_item
		[ExprAny: expr_any] :ExprAny
	|	[BlockSymbol: block_symbol] :BlockSymbol
	|	[BlockInterpret: block_interpret] :BlockInterpret
	|	['{' InlineBlock: inline_block '}'] :RecBlock

	def block_symbol
		[','] | [';'] | ['('] | [')'] | ['*'] | ['::']

	def block_interpret
		[ExprInterpret: expr_interpret] :ExprInterpret
	|	['fhold' whitespace? ';'] :Fhold
	|	['fgoto' whitespace? '*' InlineExpr: inline_expr ';'] :FgotoExpr
	|	['fnext' whitespace? '*' InlineExpr: inline_expr ';'] :FnextExpr
	|	['fcall' whitespace? '*' InlineExpr: inline_expr ';'] :FcallExpr
	|	['fexec' InlineExpr: inline_expr ';'] :Fexec
	|	['fgoto' StateRef: state_ref srlex::';'] :FgotoSr
	|	['fnext' StateRef: state_ref srlex::';'] :FnextSr
	|	['fcall' StateRef: state_ref srlex::';'] :FcallSr
	|	['fret' ';'] :Fret
	|	['fbreak' ';'] :Fbreak
end

namespace ragel
	lex
		ignore /[\t\n ]+/
		ignore /'#' any* :> '\n'/

		literal '^', '|', '-', ',', ':', '!', '?', '.'
		literal '(', ')', '{', '}', '*', '&', '+'

		literal '--', ':>', ':>>', '<:', '->', '**'

		literal '|*', '*|', '=>' 

		literal '@', '>', '<', '%', '$'
		literal 'from', 'to', 'eof', 'lerr', 'err'
		literal 'when', 'inwhen', 'outwhen', '>?', '$?', '%?' 

		literal ':=', '=', ';', '..', '::'

		literal '>~', '$~', '%~', '<~', '@~', '<>~' 
		literal '>*', '$*', '%*', '<*', '@*', '<>*' 
		literal '>/', '$/', '%/', '</', '@/', '<>/' 
		literal '>!', '$!', '%!', '<!', '@!', '<>!' 
		literal '>^', '$^', '%^', '<^', '@^', '<>^' 
		literal '<>'

		literal 'machine', 'action', 'variable', 'alphtype',
				'access', 'write', 'getkey', 'export', 'import',
				'include', 'prepush', 'postpop'

		token string /
			'"' ( [^"\\] | '\\' any )* '"' 'i'? |
			"'" ( [^'\\] | '\\' any )* "'" 'i'?
		/

		token lex_regex_open /'/'/ ni
		token lex_sqopen_pos /'['/ ni
		token lex_sqopen_neg /'[^'/ ni

		token word /[a-zA-Z_][a-zA-Z0-9_]*/
		token uint / number /
		token hex / hex_number /
	end 

	lex
		token re_dot / '.' /
		token re_star / '*' /
		token re_char / ^( '\\' | '.' | '*' | '[' | '/' ) | '\\' . any /
		token re_close / '/' /
		token re_sqopen_pos /'['/
		token re_sqopen_neg /'[^'/
	end

	lex
		token re_or_dash / '-' /
		token re_or_char / ^( '\\' | '-' | ']' ) | '\\' . any /
		token re_or_sqclose / ']' /
	end

	# Not cannot start with '{', terminated by ';', rewritten into { inline_expr }
	token _inline_expr_reparse
		/[^{;] [^;]* ';'/ {
			R: str = input.pull( match_length - 1 )
			input.pull( 1 )
			input.push( "}" )
			input.push( R )
			input.push( "{" )
		}

	token variable_name /ident/

	def inline_expr_reparse
		[_inline_expr_reparse]
	|	[ActionExpr: action_expr]

	def join
		[Join: join ',' Expr: expression] :Rec
	|	[Expr: expression] :Base

	def expression
		[Term: term ExprOpList: expression_op*]

	def expression_op
		['|' Term: term] :Or
	|	['&' Term: term] :And
	|	['-' Term: term] :Sub
	|	['--' Term: term] :Ssub

	def term
		[FactorLabel: factor_label TermOpList: term_op_list_short]

	# This list is done manually to get shortest match.
	def term_op_list_short
		[] :Empty
	|	[TermOp: term_op TermOpList: term_op_list_short] :Terms

	def term_op
		[FactorLabel: factor_label] :None
	|	['.' FactorLabel: factor_label] :Dot
	|	[':>' FactorLabel: factor_label] :ColonLt
	|	[':>>' FactorLabel: factor_label] :ColonLtLt
	|	['<:' FactorLabel: factor_label] :GtColon

	def factor_label
		[Label: word ':' FactorLabel: factor_label] :Label
	|	[FactorEp: factor_ep] :Ep

	def factor_ep
		[FactorAug: factor_aug '->' EpsilonTarget: epsilon_target] :Epsilon
	|	[FactorAug: factor_aug] :Base

	def epsilon_target
		[EpsilonTarget: epsilon_target '::' Word: word] :Rec
	|	[Word: word] :Base

	def action_expr
		['{' InlineExpr: c_inline::inline_expr '}']

	def action_block
		['{' InlineBlock: c_inline::inline_block '}']

	def action_ref 
		[Word: word] :Word
	|	['(' Word: word ')'] :ParenWord
	|	[ActionBlock: action_block] :Block
	
	def priority_aug
		[uint]
	|	['+' uint]
	|	['-' uint]

	def aug_base
		['@'] :Finish | ['>'] :Enter | ['%'] :Leave | ['$'] :All

	def aug_cond
		['>?'] :Start1 | ['$?'] :All1 | ['%?'] :Leave1
	|	['>' 'when'] :Start2 | ['$' 'when'] :All2 | ['%' 'when'] :Leave2
	|	['inwhen'] :Start3 | ['when'] :All3 | ['outwhen'] :Leave3

	def aug_to_state
		['>~'] :Start1 | ['<~'] :NotStart1 | ['$~'] :All1
	|	['%~'] :Final1 | ['@~'] :NotFinal1 | ['<>~'] :Middle1
	|	['>' 'to'] :Start2 | ['<' 'to'] :NotStart2 | ['$' 'to'] :All2
	|	['%' 'to'] :Final2 | ['@' 'to'] :NotFinal2 | ['<>' 'to'] :Middle2

	def aug_from_state
		['>*'] :Start1 | ['<*'] :NotStart1 | ['$*'] :All1
	|	['%*'] :Final1 | ['@*'] :NotFinal1 | ['<>*'] :Middle1
	|	['>' 'from'] :Start2 | ['<' 'from'] :NotStart2 | ['$' 'from'] :All2
	|	['%' 'from'] :Final2 | ['@' 'from'] :NotFinal2 | ['<>' 'from'] :Middle2

	def aug_eof
		['>/'] :Start1 | ['</'] :NotStart1 | ['$/'] :All1
	|	['%/'] :Final1 | ['@/'] :NotFinal1 | ['<>/'] :Middle1
	|	['>' 'eof'] :Start2 | ['<' 'eof'] :NotStart2 | ['$' 'eof'] :All2
	|	['%' 'eof'] :Final2 | ['@' 'eof'] :NotFinal2 | ['<>' 'eof'] :Middle2

	def aug_gbl_error
		['>!'] :Start1 | ['<!'] :NotStart1 | ['$!'] :All1
	|	['%!'] :Final1 | ['@!'] :NotFinal1 | ['<>!'] :Middle1
	|	['>' 'err'] :Start2 | ['<' 'err'] :NotStart2 | ['$' 'err'] :All2
	|	['%' 'err'] :Final2 | ['@' 'err'] :NotFinal2 | ['<>' 'err'] :Middle2

	def aug_local_error
		['>^'] :Start1 | ['<^'] :NotStart1 | ['$^'] :All1
	|	['%^'] :Final1 | ['@^'] :NotFinal1 | ['<>^'] :Middle1
	|	['>' 'lerr'] :Start2 | ['<' 'lerr'] :NotStart2 | ['$' 'lerr'] :All2
	|	['%' 'lerr'] :Final2 | ['@' 'lerr'] :NotFinal2 | ['<>' 'lerr'] :Middle2

	def factor_aug
		[FactorAug: factor_aug AugBase: aug_base ActionRef: action_ref] :ActionRef
	|	[FactorAug: factor_aug AugBase: aug_base PriorityAug: priority_aug] :PriorEmbed
	|	[FactorAug: factor_aug AugBase: aug_base '(' Name: word ',' PriorityAug: priority_aug ')'] :NamedPriorEmbed
	|	[FactorAug: factor_aug AugCond: aug_cond ActionRef: action_ref] :CondEmbed
	|	[FactorAug: factor_aug AugCond: aug_cond '!' ActionRef: action_ref] :NegCondEmbed
	|	[FactorAug: factor_aug AugToState: aug_to_state ActionRef: action_ref] :ToStateAction
	|	[FactorAug: factor_aug AugFromState: aug_from_state ActionRef: action_ref] :FromStateAction
	|	[FactorAug: factor_aug AugEof: aug_eof ActionRef: action_ref] :EofAction
	|	[FactorAug: factor_aug AugGblError: aug_gbl_error ActionRef: action_ref] :GblErrorAction
	|	[FactorAug: factor_aug AugLocalError: aug_local_error ActionRef: action_ref] :LocalErrorDef
	|	[FactorAug: factor_aug AugLocalError: aug_local_error '(' ErrName: word ',' ActionRef: action_ref ')'] :LocalErrorName
	|	[FactorRep: factor_rep] :Base

	def factor_rep 
		[FactorNeg: factor_neg OpList: factor_rep_op*]

	def factor_rep_op
		['*'] :Star
	|	['**'] :StarStar
	|	['?'] :Optional
	|	['+'] :Plus
	|	['{' Rep: factor_rep_num '}'] :ExactRep
	|	['{' ',' Rep: factor_rep_num '}'] :MaxRep
	|	['{' Rep: factor_rep_num ',' '}'] :MinRep
	|	['{' LowRep: factor_rep_num ',' HighRep: factor_rep_num '}'] :RangeRep

	def factor_rep_num
		[uint]

	def factor_neg 
		['!' FactorNeg: factor_neg] :Bang
	|	['^' FactorNeg: factor_neg] :Caret
	|	[Factor: factor] :Base

	def factor 
		[AN: alphabet_num] :AlphabetNum
	|	[W: word] :Word
	|	[S: string] :String
	|	[lex_sqopen_pos PosData: reg_or_data re_or_sqclose] :PosOrBlock
	|	[lex_sqopen_neg NegData: reg_or_data re_or_sqclose] :NegOrBlock
	|	[lex_regex_open Regex: regex re_close] :Regex
	|	[RL1: range_lit '..' RL2: range_lit] :Range
	|	['(' Join: join ')'] :Join

	def regex
		[RegItemRepList: reg_item_rep*]

	def reg_item_rep
		[RegItem: reg_item re_star] :Star
	|	[RegItem: reg_item] :Base

	def reg_item
		[re_sqopen_pos PosData: reg_or_data re_or_sqclose] :PosOrBlock
	|	[re_sqopen_neg NegData: reg_or_data re_or_sqclose] :NegOrBlock
	|	[re_dot] :Dot
	|	[Char: re_char] :Char

	def reg_or_data
		[Data: reg_or_data Char: reg_or_char] :Data
	|	[] :Base

	def reg_or_char
		[Char: re_or_char] :Char
	|	[Low: re_or_char re_or_dash High: re_or_char] :Range

	def range_lit
		[String: string] :String
	|	[AN: alphabet_num] :AN

	def alphabet_num 
		[uint]
	|	['-' uint]
	|	[hex]

	def lm_act
		['=>' ActionRef: action_ref] :ActionRef
	|	[ActionBlock: action_block] :ActionBlock

	def opt_lm_act
		[LmAct: lm_act]
	|	[]

	def lm_stmt
		[Join: join OptLmAct: opt_lm_act ';'] :LmStmt commit
	|	[Assignment: assignment] :Assignment
	|	[ActionSpec: action_spec] :ActionSpec

	def lm_stmt_list
		[LmStmtList: lm_stmt_list LmStmt: lm_stmt] :Rec
	|	[LmStmt: lm_stmt] :Base

	def lm
		[Join: join] :Join
	|	['|*' LmStmtList: lm_stmt_list '*|'] :Lm

	def action_spec
		['action' Name: word ActionBlock: action_block] commit

	def assignment
		[OptExport: opt_export Name: word '=' Join: join ';'] commit

	def instantiation
		[OptExport: opt_export Name: word ':=' Lm: lm ';'] commit

	def alphtype_type
		[W1: word] :One
	|	[W1: word W2: word] :Two

	def include_spec
		[Word: word] 
	|	[String: string]
	|	[Word: word String: string]

	def opt_export
		['export'] :Export
	|	[] :Base

	def machine_name
		['machine' MachineName: word ';']

	def statement
		[MachineName: machine_name] :MachineName commit
	|	[Assignment: assignment] :Assignment
	|	[Instantiation: instantiation] :Instantiation
	|	[ActionSpec: action_spec] :ActionSpec
	|	['prepush' PrePushBlock: action_block] :PrePushSpec commit
	|	['postpop' PostPopBlock: action_block] :PostPopSpec commit
	|	['variable' Var: variable_name Reparse: inline_expr_reparse] :Variable commit
	|	['alphtype' AlphTypeType: alphtype_type ';'] :AlphType commit
	|	['access' Reparse: inline_expr_reparse] :Access commit
	|	['write' Cmd: word ArgList: word* ';'] :Write commit
	|	['getkey' Reparse: inline_expr_reparse] :GetKey commit
	|	['import' ImportFn: string ';'] :Import commit
	|	['include' IncludeSpec: include_spec ';'] :Include commit

	def ragel_start 
		[statement*]
end

namespace c_host
	lex 
		literal '%%{', '}%%'

		token slr /'%%' [^{] [^\n]* '\n'/
		{
			input.pull( 2 )
			R: str = input.pull( match_length - 3 )
			input.push( "}%%" )
			input.push( R )
			input.push( "%%{" )
		}

		rl NL / '\n' /

		rl ruby_comment / '#' [^\n]* NL /

		rl s_literal
			/ "'" ([^'\\] | NL | '\\' (any | NL))* "'" /

		rl d_literal
			/ '"' ([^"\\] | NL | '\\' (any | NL))* '"' /

		rl host_re_literal
			/ '/' ([^/\\] | NL | '\\' (any | NL))* '/' /

		token ident /ident/
		token number /digit+/
		token hex_number /'0x' [0-9a-fA-F]+/

		token comment
			/c_comment | cpp_comment/

		token string
			/ s_literal | d_literal /

		token whitespace
			/ ( [ \t] | NL )+ /

		token c_any / any /
	end

	def tok
		[ident]
	|	[number]
	|	[hex_number]
	|	[comment]
	|	[string]
	|	[whitespace]
	|	[c_any]

	def section
		['%%{' StmtList: ragel::statement* '}%%'] :MultiLine
	|	[Tok: tok] :Tok
end

