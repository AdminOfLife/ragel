int d_tok_list( TL: host::tok* )
{
	for Tok: host::tok in repeat(TL) {
		if match Tok [host::'${' StmtList: stmt* host::'}$']
			d_stmt_list( StmtList )
		elsif match Tok [host::'={' Expr: expr host::'}=']
			d_expr( Expr )
		else {
			send Output [Tok]
		}
	}
}

int d_expr_factor( ExprFactor: expr_factor )
{
	if match ExprFactor
		['$' string uint '{' TL: host::tok* host::'}$']
	{
		d_tok_list( TL )
	}
	elsif match ExprFactor
		['=' string uint '{' TL: host::tok* host::'}$']
	{
		d_tok_list( TL )
	}
	elsif match ExprFactor
		[O:'(' TL: expr C: ')']
	{
		send Output [O]
		d_expr( TL )
		send Output [C]
	}
	elsif match ExprFactor
		[ident O: '[' TL: expr C: ']']
	{
		send Output [ExprFactor.ident]
		send Output [O]
		d_expr( TL )
		send Output [C]
	}
	elsif match ExprFactor
		['offset' '(' ident ',' expr ')']
	{
		send Output ['&' ExprFactor.ident '[']
		d_expr( ExprFactor.expr )
		send Output [']']
	}
	elsif match ExprFactor
		['deref' '(' ident ',' expr ')']
	{
		send Output [ '(*(']
		d_expr( ExprFactor.expr )
		send Output ['))']
	}
	elsif match ExprFactor
			[T: 'TRUE']
	{
		T.data = '1'
		send Output [T]
	}
	elsif match ExprFactor
			[F: 'FALSE']
	{
		F.data = '0'
		send Output [F]
	}
	elsif match ExprFactor
			[N: 'nil']
	{
		N.data = 'null'
		send Output [N]
	}
	else {
		# Catches cases not specified
		send Output [ExprFactor]
	}
}

int d_expr_ptr( ExprPtr: expr_ptr )
{
	if match ExprPtr [expr_ptr Arrow: '->' expr_factor]
	{
		d_expr_ptr( ExprPtr._expr_ptr )
		send Output [Arrow]
		d_expr_factor( ExprPtr.expr_factor )
	}
	elsif match ExprPtr [Star: '*' expr_ptr]
	{
		send Output [Star]
		d_expr_ptr( ExprPtr._expr_ptr )
	}
	elsif match ExprPtr [PP: '++' expr_ptr]
	{
		send Output [PP]
		d_expr_ptr( ExprPtr._expr_ptr )
	}
	elsif match ExprPtr [MM: '--' expr_ptr]
	{
		send Output [MM]
		d_expr_ptr( ExprPtr._expr_ptr )
	}
	elsif match ExprPtr [expr_ptr PP: '++']
	{
		d_expr_ptr( ExprPtr._expr_ptr )
		send Output [PP]
	}
	elsif match ExprPtr [expr_ptr MM: '--']
	{
		d_expr_ptr( ExprPtr._expr_ptr )
		send Output [MM]
	}
	elsif match ExprPtr [Open: '(' Type: type Close: ')' expr_ptr]
	{
		send Output ['cast' Open]
		d_type( Type )
		send Output [Close]
		d_expr_ptr( ExprPtr._expr_ptr )
	}
	elsif match ExprPtr [expr_factor]
	{
		d_expr_factor( ExprPtr.expr_factor )
	}
	else {
		send Output [ExprPtr]
	}
}

int d_expr_factor_op( ExprFactorOp: expr_factor_op )
{
	if match ExprFactorOp [B: '!' expr_factor_op]
	{
		send Output [B]
		d_expr_factor_op( ExprFactorOp._expr_factor_op )
	}
	elsif match ExprFactorOp [T: '~' expr_factor_op]
	{
		send Output [T]
		d_expr_factor_op( ExprFactorOp._expr_factor_op )
	}
	elsif match ExprFactorOp [expr_ptr]
	{
		d_expr_ptr( ExprFactorOp.expr_ptr )
	}
}

int d_expr_bitwise( ExprBitwise: expr_bitwise )
{
	if match ExprBitwise [expr_bitwise A: '&' expr_factor_op]
	{
		d_expr_bitwise( ExprBitwise._expr_bitwise )
		send Output [A]
		d_expr_factor_op( ExprBitwise.expr_factor_op )
	}
	elsif match ExprBitwise [expr_factor_op]
	{
		d_expr_factor_op( ExprBitwise.expr_factor_op )
	}
}

int d_expr_mult( ExprMult: expr_mult )
{
	if match ExprMult [expr_mult T: '*' expr_bitwise]
	{
		d_expr_mult( ExprMult._expr_mult )
		send Output [T]
		d_expr_bitwise( ExprMult.expr_bitwise )
	}
	elsif match ExprMult [expr_bitwise]
	{
		d_expr_bitwise( ExprMult.expr_bitwise )
	}
}

int d_expr_add( ExprAdd: expr_add )
{
	if match ExprAdd [expr_add Op: add_op expr_mult]
	{
		d_expr_add( ExprAdd._expr_add )
		send Output [Op]
		d_expr_mult( ExprAdd.expr_mult )
	}
	elsif match ExprAdd [expr_mult]
	{
		d_expr_mult( ExprAdd.expr_mult )
	}
}

int d_expr_shift( ExprShift: expr_shift )
{
	if match ExprShift [expr_shift Op: shift_op expr_add]
	{
		d_expr_shift( ExprShift._expr_shift )
		send Output [Op]
		d_expr_add( ExprShift.expr_add )
	}
	elsif match ExprShift [expr_add]
	{
		d_expr_add( ExprShift.expr_add )
	}
}

int d_expr_test( ExprTest: expr_test )
{
	if match ExprTest [expr_test Op: test_op expr_shift]
	{
		d_expr_test( ExprTest._expr_test )
		send Output [Op]
		d_expr_shift( ExprTest.expr_shift )
	}
	elsif match ExprTest [expr_shift]
	{
		d_expr_shift( ExprTest.expr_shift )
	}
}

int d_expr_cond( ExprCond: expr_cond )
{
	d_expr_test( ExprCond.expr_test )
}

int d_expr_assign( ExprAssign: expr_assign )
{
	if match ExprAssign [expr_assign Op: assign_op expr_cond]
	{
		d_expr_assign( ExprAssign._expr_assign )
		send Output [Op]
		d_expr_cond( ExprAssign.expr_cond )
	}
	elsif match ExprAssign [expr_cond]
	{
		d_expr_cond( ExprAssign.expr_cond )
	}
}

int d_expr( Expr: expr )
{
	d_expr_assign( Expr.expr_assign )
}

int d_type( Type: type )
{
	if match Type "s8"
		send Output ['byte ']
	elsif match Type "s16"
		send Output ['short ']
	elsif match Type "s32"
		send Output ['int ']
	elsif match Type "s64"
		send Output ['long ']
	elsif match Type "s128"
		send Output ['long long ']
	else
		send Output [Type]
}

int d_stmt( Stmt: stmt )
{
	if match Stmt
		['$' string uint '{' TL: host::tok* host::'}$']
	{
		d_tok_list( TL )
	}
	elsif match Stmt
		['=' string uint '{' TL: host::tok* host::'}$']
	{
		d_tok_list( TL )
	}
	elsif match Stmt [Array: array] {
		send Output ['static const ']
		d_type( Array.type )
		send Output [Array.ident '[] = [ ' Array.num_list ' ];\n']
	}
	elsif match Stmt [Value: value] {
		send Output ['static const ' Value.value_pass]
	}
	elsif match Stmt [
			'if' O: '(' IfExpr: expr C: ')' IfStmt: stmt
			ElseIfClauseList: else_if_clause* ElseClauseOpt: else_clause?
	] {
		send Output ['if ' O]
		d_expr( IfExpr )
		send Output [C]

		d_stmt( IfStmt )

		for ElseIfClause: else_if_clause in repeat( ElseIfClauseList ) {
			match ElseIfClause
				['else' 'if' O2: '(' ElseIfExpr: expr C2: ')' ElseIfStmt: stmt]

			send Output ['else if ' O2]
			d_expr( ElseIfExpr )
			send Output [C2]

			d_stmt( ElseIfStmt )
		}

		if ( match ElseClauseOpt ['else' ElseStmt: stmt] ) {
			send Output ['else ']
			d_stmt( ElseStmt )
		}
	}
	elsif match Stmt ['while' O: '(' WhileExpr: expr C: ')' WhileStmt: stmt] {
		send Output ['while ' O]
		d_expr( WhileExpr )
		send Output [C]
		d_stmt( WhileStmt )
	}
	elsif match Stmt ['switch' O: '(' SwitchExpr: expr C: ')' '{' StmtList: stmt* '}'] {
		send Output ['switch ' O]
		d_expr( SwitchExpr )
		send Output [C '{']
		d_stmt_list( StmtList )
		send Output ['default: break; }']
	}
	elsif match Stmt [ExprExpr: expr Semi: ';'] {
		d_expr( ExprExpr )
		send Output [Semi]
	}
	elsif match Stmt [L: '{' TL: stmt* R: '}'] {
		send Output [L]
		d_stmt_list( TL )
		send Output [R]
	}
	elsif match Stmt [OptConst: opt_const Type: type OptPtr: opt_ptr Ident: ident OptInit: opt_init Semi: ';']
	{
		if match OptConst ['const']
		{
			send Output ['const(']
			d_type( Type )
			send Output [')']
		}
		else
			d_type( Type )
		send Output [OptPtr Ident]
		if match OptInit [E: '=' expr] {
			send Output [E]
			d_expr( OptInit.expr )
		}
		send Output [Semi]
	}
	elsif match Stmt [case_label]
	{
		send Output [Stmt.case_label]
	}
	elsif match Stmt [export_stmt]
	{
		send Output ["static const "]
		d_type( Stmt.export_stmt.type )
		send Output [' ' Stmt.export_stmt.ident ' = ' Stmt.export_stmt.number ';\n']
	}
	elsif match Stmt ['fallthrough' ';']
	{
		send Output ['goto case;']
	}
	elsif match Stmt [index_stmt]
	{
		send Output ['const(']
		d_type( Stmt.index_stmt.type )
		send Output [') * ' Stmt.index_stmt.ident ';\n']
	}
	else {
		# catches unspecified cases
		send Output [Stmt]
	}
}

int d_stmt_list( StmtList: stmt* )
{
	for Stmt: stmt in repeat( StmtList )
		d_stmt( Stmt )
}


